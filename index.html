<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecopiensa Editor | Instagram Composer</title>
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --bg-hover: #2d2d2d;
            --accent: #00ff9d;
            --text-main: #ffffff;
            --text-muted: #a0a0a0;
            --border: #333;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --ruler-bg: #2a2a2a;
            --ruler-tick: #888;
            --guide-color: #ff00ff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-rows: 60px 1fr;
            grid-template-columns: 70px 1fr 300px;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            grid-column: 1 / -1;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .logo { font-weight: 700; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .logo span { color: var(--accent); }
        .canvas-info { font-size: 0.8rem; color: var(--text-muted); margin-left: 10px; background: #333; padding: 2px 6px; border-radius: 4px; }

        .header-controls { display: flex; gap: 15px; align-items: center; }

        .zoom-controls { display: flex; align-items: center; gap: 8px; background: var(--bg-dark); padding: 4px 10px; border-radius: 20px; border: 1px solid var(--border); }
        .zoom-slider { width: 100px; accent-color: var(--accent); cursor: pointer; }

        button, select.header-select {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        button:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        button.primary { background: var(--accent); color: #000; font-weight: 600; border: none; }
        button.primary:hover:not(:disabled) { opacity: 0.9; }
        
        button.active-tool { background: rgba(0, 255, 157, 0.1); color: var(--accent); border-color: var(--accent); }

        /* --- Toolbar Left --- */
        .toolbar {
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 15px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-muted);
            border: 1px solid transparent;
            position: relative;
        }

        .tool-btn:hover { background: var(--bg-hover); color: var(--text-main); }
        .tool-btn.active { background: rgba(0, 255, 157, 0.1); color: var(--accent); border-color: var(--accent); }
        .tool-tooltip {
            position: absolute; left: 120%; background: #000; padding: 5px 10px; 
            border-radius: 4px; font-size: 0.8rem; pointer-events: none; opacity: 0; transition: opacity 0.2s; white-space: nowrap; z-index: 10;
        }
        .tool-btn:hover .tool-tooltip { opacity: 1; }

        /* --- Canvas Area & Rulers --- */
        .workspace {
            background-color: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        #canvas-wrapper {
            position: relative;
            padding: 30px 0 0 30px; /* Space for rulers */
            transition: transform 0.1s;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* Rulers */
        .ruler-h {
            position: absolute; top: 0; left: 30px; right: 0; height: 30px;
            background: var(--ruler-bg); border-bottom: 1px solid var(--border);
            display: flex; overflow: hidden;
            font-size: 10px; color: #fff; /* Texto más visible */
            font-weight: bold;
        }
        .ruler-v {
            position: absolute; top: 30px; left: 0; bottom: 0; width: 30px;
            background: var(--ruler-bg); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; overflow: hidden;
            font-size: 10px; color: #fff; /* Texto más visible */
            font-weight: bold;
        }
        .ruler-corner {
            position: absolute; top: 0; left: 0; width: 30px; height: 30px;
            background: var(--bg-panel); border-right: 1px solid var(--border); border-bottom: 1px solid var(--border);
            z-index: 10;
        }
        .tick { position: absolute; background: var(--ruler-tick); }
        .tick-label { position: absolute; font-size: 9px; color: #ddd; pointer-events: none; }
        
        .tick-h-major { height: 100%; width: 1px; top: 0; background: #666; }
        .tick-h-minor { height: 30%; width: 1px; bottom: 0; }
        .label-h { top: 2px; transform: translateX(4px); }
        
        .tick-v-major { width: 100%; height: 1px; left: 0; background: #666; }
        .tick-v-minor { width: 30%; height: 1px; right: 0; }
        .label-v { left: 2px; transform: translateY(4px) rotate(-90deg); transform-origin: left top; }

        canvas { display: block; background: #1a1a1a; cursor: crosshair; }

        /* --- Properties Panel Right --- */
        .properties {
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section { margin-bottom: 25px; }
        .panel-title { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 10px; font-weight: 700; }

        .control-group { margin-bottom: 15px; }
        .control-label { display: block; font-size: 0.9rem; margin-bottom: 5px; }
        
        input[type="text"], input[type="number"], select, textarea {
            width: 100%; background: var(--bg-dark); border: 1px solid var(--border); color: var(--text-main);
            padding: 8px; border-radius: 4px; outline: none;
        }
        input:focus, textarea:focus { border-color: var(--accent); }

        input[type="range"] { width: 100%; accent-color: var(--accent); }
        
        .layer-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        .btn-full { width: 100%; justify-content: center; margin-bottom: 10px; background: #333; }
        .btn-full:hover { background: #444; }

        /* --- Instagram Preview Modal --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; display: none;
            overflow-y: auto;
            justify-content: center; 
            padding: 40px 20px;
            align-items: flex-start;
        }
        .modal-overlay.open { display: flex; }
        
        .modal-content {
            display: flex;
            gap: 20px;
            background: #151515;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            margin: auto;
            position: relative;
        }

        .ig-preview {
            background: #000; width: 375px; height: 700px; border-radius: 20px;
            border: 8px solid #333; overflow: hidden; position: relative;
            display: flex; flex-direction: column;
            flex-shrink: 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .ig-header { height: 50px; border-bottom: 1px solid #333; display: flex; align-items: center; padding: 0 15px; font-size: 0.9rem; font-weight: bold; }
        .ig-avatar { width: 30px; height: 30px; border-radius: 50%; background: #555; margin-right: 10px; background-size: cover; background-position: center; }
        .ig-content { width: 100%; aspect-ratio: 1/1; background: #222; margin-top: 10px; }
        .ig-content img { width: 100%; height: 100%; object-fit: contain; }
        .ig-actions { padding: 10px 15px; display: flex; gap: 15px; }
        .ig-caption { padding: 0 15px; font-size: 0.85rem; color: #eee; }
        
        .close-modal-btn {
            position: absolute; top: -15px; right: -15px; 
            width: 32px; height: 32px; background: var(--accent); color: #000;
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            cursor: pointer; font-weight: bold; box-shadow: 0 2px 10px rgba(0,255,157,0.3);
            z-index: 200;
        }
        
        /* Profile Editor in Modal */
        .profile-editor {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .profile-editor h3 { font-size: 1rem; color: var(--accent); margin-bottom: 10px; }

        /* Responsive */
        @media (max-width: 900px) {
            .modal-content { flex-direction: column; max-height: none; }
            .modal-overlay { align-items: flex-start; }
        }
        @media (max-width: 768px) {
            body { grid-template-columns: 50px 1fr; grid-template-rows: 50px 1fr 200px; }
            .properties { grid-column: 1 / -1; border-top: 1px solid var(--border); border-left: none; }
            .header-controls span:not(#zoom-level) { display: none; }
            .zoom-slider { width: 60px; }
        }
    </style>
</head>
<body>

    <!-- Header -->
    <header>
        <div class="logo">
            <i data-lucide="layout-grid"></i>
            Ecopiensa<span>Editor</span>
            <div class="canvas-info" id="canvas-dims">1080x1080 px</div>
        </div>
        <div class="header-controls">
            <!-- Format Selector -->
            <select class="header-select" id="canvas-format" onchange="app.changeFormat(this.value)" title="Formato de Publicación">
                <option value="square">Cuadrado (1:1)</option>
                <option value="portrait">Vertical (4:5)</option>
            </select>

            <!-- Undo Button -->
            <button onclick="app.undo()" id="undo-btn" title="Deshacer (Ctrl+Z)" disabled>
                <i data-lucide="undo-2"></i> <span>Deshacer</span>
            </button>
            
            <div style="width: 1px; height: 20px; background: #333; margin: 0 5px;"></div>

            <!-- Horizontal Zoom Controls -->
            <div class="zoom-controls">
                <i data-lucide="search" size="14" style="color:#666"></i>
                <input type="range" class="zoom-slider" min="0.1" max="2.0" step="0.1" value="1.0" oninput="app.setZoom(this.value)">
                <span id="zoom-level" style="font-size: 0.8rem; width: 40px; text-align: right;">100%</span>
            </div>

            <button id="safe-zone-btn" onclick="app.toggleSafeZone()" title="Mostrar/Ocultar Zona Segura"><i data-lucide="grid-3x3"></i> <span>Guías</span></button>
            <button onclick="app.toggleGridPreview()"><i data-lucide="smartphone"></i> <span>Vista Previa</span></button>
            <select id="export-format" class="header-select" style="width: auto;">
                <option value="image/png">PNG</option>
                <option value="image/jpeg">JPG</option>
                <option value="image/webp">WebP</option>
            </select>
            <button class="primary" onclick="app.exportImage()"><i data-lucide="download"></i> <span>Exportar</span></button>
        </div>
    </header>

    <!-- Toolbar -->
    <aside class="toolbar">
        <button class="tool-btn active" onclick="app.setTool('move')" id="tool-move">
            <i data-lucide="move"></i><span class="tool-tooltip">Mover/Seleccionar (V)</span>
        </button>
        <button class="tool-btn" onclick="document.getElementById('file-upload').click()">
            <i data-lucide="image-plus"></i><span class="tool-tooltip">Añadir Imagen</span>
        </button>
        <button class="tool-btn" onclick="app.addTextLayer()">
            <i data-lucide="type"></i><span class="tool-tooltip">Añadir Texto (T)</span>
        </button>
        <div style="height: 1px; width: 30px; background: #333; margin: 5px 0;"></div>
        <button class="tool-btn" onclick="app.setTool('crop')" id="tool-crop">
            <i data-lucide="crop"></i><span class="tool-tooltip">Recorte Inteligente (C)</span>
        </button>
        <button class="tool-btn" onclick="app.setTool('eraser')" id="tool-eraser">
            <i data-lucide="eraser"></i><span class="tool-tooltip">Borrador (E)</span>
        </button>
        <button class="tool-btn" onclick="app.setTool('magic-wand')" id="tool-magic-wand">
            <i data-lucide="wand-2"></i><span class="tool-tooltip">Varita Mágica (W)</span>
        </button>
        <button class="tool-btn" onclick="app.setTool('fill')" id="tool-fill">
            <i data-lucide="paint-bucket"></i><span class="tool-tooltip">Relleno (F)</span>
        </button>
        
        <!-- Hidden Inputs -->
        <input type="file" id="file-upload" accept="image/*" hidden onchange="app.handleImageUpload(this)">
        <input type="file" id="file-replace" accept="image/*" hidden onchange="app.handleImageReplace(this)">
        <input type="file" id="bg-upload" accept="image/*" hidden onchange="app.handleBackgroundUpload(this)">
    </aside>

    <!-- Workspace -->
    <main class="workspace" id="workspace">
        <div id="canvas-wrapper">
            <div class="ruler-corner"></div>
            <div class="ruler-h" id="ruler-h"></div>
            <div class="ruler-v" id="ruler-v"></div>
            
            <div id="canvas-container">
                <canvas id="main-canvas" width="1080" height="1080"></canvas>
            </div>
        </div>
    </main>

    <!-- Properties Panel -->
    <aside class="properties" id="properties-panel">
        <div class="panel-section">
            <div class="panel-title">Lienzo</div>
            <div class="control-group">
                <label class="control-label">Color de Fondo</label>
                <input type="color" id="bg-color" value="#1a1a1a" style="height: 40px; width: 100%;">
            </div>
            <div class="control-group">
                <label class="control-label">Imagen de Fondo</label>
                <div style="display:flex; gap:5px;">
                    <button onclick="document.getElementById('bg-upload').click()" style="flex:1;"><i data-lucide="image"></i> Subir Fondo</button>
                    <button onclick="app.clearBackground()" style="width:40px; justify-content:center;" title="Quitar Fondo"><i data-lucide="trash-2"></i></button>
                </div>
                <div style="font-size: 0.75rem; color: #777; margin-top: 5px;">
                    Se ajusta automáticamente al formato.
                </div>
            </div>
        </div>

        <div id="layer-properties" style="display:none;">
            <div class="panel-section">
                <div class="panel-title" id="prop-title">Propiedades de Capa</div>
                
                <!-- Image Specific Controls -->
                <div id="image-controls" style="display:none;">
                    <button class="btn-full" onclick="document.getElementById('file-replace').click()">
                        <i data-lucide="refresh-cw" size="16"></i> Reemplazar Imagen
                    </button>
                    <div style="font-size: 0.75rem; color: #777; margin-bottom: 15px; text-align: center;">
                        Mantiene posición y tamaño
                    </div>
                </div>

                <!-- Text Controls -->
                <div id="text-controls" style="display:none;">
                    <div class="control-group">
                        <label class="control-label">Contenido</label>
                        <!-- Changed to Textarea for better writing experience -->
                        <textarea id="prop-text-content" rows="3" placeholder="Escribe aquí..."></textarea>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Ancho de Caja (Wrap)</label>
                        <input type="range" id="prop-text-width" min="100" max="1000" value="500">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Fuente</label>
                        <select id="prop-font">
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Impact">Impact</option>
                            <option value="Brush Script MT">Brush Script</option>
                            <option disabled>───────</option>
                            <option value="Roboto Slab">Slab Serif</option>
                            <option value="Roboto Slab|uppercase">Slab Serif (Mayúsculas)</option>
                            <option value="Roboto Slab|lowercase">Slab Serif (Minúsculas)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Color</label>
                        <input type="color" id="prop-color" style="height: 40px;">
                    </div>
                </div>

                <!-- Transform Controls -->
                <div class="control-group">
                    <label class="control-label">Opacidad</label>
                    <input type="range" id="prop-opacity" min="0" max="1" step="0.01">
                </div>

                <!-- Ordering/Actions -->
                <div class="panel-title" style="margin-top: 20px;">Acciones</div>
                <div class="layer-actions">
                    <button onclick="app.reorderLayer('up')"><i data-lucide="arrow-up"></i> Subir</button>
                    <button onclick="app.reorderLayer('down')"><i data-lucide="arrow-down"></i> Bajar</button>
                    <button onclick="app.centerLayer()"><i data-lucide="align-center"></i> Centrar</button>
                    <button onclick="app.deleteLayer()" style="background: #ff4444; color: white; border: none;"><i data-lucide="trash-2"></i></button>
                </div>
            </div>
            
            <!-- Tool Specific Settings -->
            <div id="tool-settings" class="panel-section" style="display:none; border-top: 1px solid #333; padding-top: 20px;">
                <div class="panel-title">Ajustes de Herramienta</div>
                
                <div id="crop-settings" style="display:none;">
                    <div style="font-size: 0.8rem; color: #aaa; margin-bottom: 10px;">
                        Selecciona un área rectangular sobre la <strong>capa seleccionada</strong>. Lo que quede fuera se borrará.
                    </div>
                    <button class="primary" style="width: 100%;" disabled id="apply-crop-btn">Aplicar Recorte</button>
                </div>

                <div id="eraser-settings" style="display:none;">
                    <label class="control-label">Tamaño Borrador: <span id="eraser-size-val">20</span>px</label>
                    <input type="range" id="eraser-size" min="5" max="100" value="20">
                </div>
                
                <div id="wand-settings" style="display:none;">
                    <label class="control-label">Tolerancia: <span id="wand-tol-val">30</span></label>
                    <input type="range" id="wand-tol" min="0" max="100" value="30">
                </div>

                <div id="fill-settings" style="display:none;">
                    <label class="control-label">Color de Relleno</label>
                    <input type="color" id="fill-color" value="#00ff9d" style="height: 40px; width: 100%; margin-bottom: 10px;">
                    <label class="control-label">Tolerancia: <span id="fill-tol-val">30</span></label>
                    <input type="range" id="fill-tol" min="0" max="100" value="30">
                </div>
            </div>
        </div>
        
        <div id="no-selection-msg" style="color: #666; font-style: italic; text-align: center; margin-top: 20px;">
            Selecciona un objeto para editar sus propiedades.
        </div>
    </aside>

    <!-- Preview & Profile Settings Modal -->
    <div class="modal-overlay" id="preview-modal" onclick="if(event.target === this) app.toggleGridPreview()">
        <div class="modal-content">
            <div class="close-modal-btn" onclick="app.toggleGridPreview()">
                <i data-lucide="x" size="20"></i>
            </div>
            
            <!-- Phone Preview -->
            <div class="ig-preview">
                <div class="ig-header">
                    <div class="ig-avatar" id="prev-avatar"></div>
                    <span id="prev-username">ecopiensa_oficial</span>
                </div>
                <div class="ig-content">
                    <img id="preview-img" src="">
                </div>
                <div class="ig-actions">
                    <i data-lucide="heart"></i>
                    <i data-lucide="message-circle"></i>
                    <i data-lucide="send"></i>
                </div>
                <div class="ig-caption">
                    <strong id="prev-username-cap">ecopiensa_oficial</strong> <span id="prev-caption-text">Nueva composición creada con Ecopiensa Editor. #design #eco #instagram</span>
                </div>
            </div>

            <!-- Profile Editor Sidebar -->
            <div class="profile-editor">
                <h3>Personalizar Perfil</h3>
                <div class="control-group">
                    <label class="control-label">Usuario Instagram</label>
                    <input type="text" id="profile-name" value="ecopiensa_oficial" oninput="app.updateProfilePreview()">
                </div>
                <div class="control-group">
                    <label class="control-label">Foto de Perfil</label>
                    <input type="file" id="profile-pic-input" accept="image/*" style="display:none" onchange="app.handleProfilePic(this)">
                    <button onclick="document.getElementById('profile-pic-input').click()" style="width: 100%;">
                        <i data-lucide="upload"></i> Subir Foto
                    </button>
                </div>
                <div class="control-group">
                    <label class="control-label">Texto del Post</label>
                    <textarea id="profile-caption" rows="4" oninput="app.updateProfilePreview()" style="width: 100%; background: #121212; color: white; border: 1px solid #333; padding: 8px; border-radius: 4px;">Nueva composición creada con Ecopiensa Editor. #design #eco #instagram</textarea>
                </div>
                <div style="margin-top: auto; font-size: 0.8rem; color: #777;">
                    <i data-lucide="info" size="14" style="vertical-align: middle;"></i> 
                    La API de Instagram no permite publicar directamente desde la web. Personaliza aquí tu vista previa y luego usa "Exportar" para subir la imagen manualmente.
                </div>
            </div>
        </div>
    </div>

    <!-- Application Logic -->
    <script type="module">
        lucide.createIcons();

        // --- Clases Principales ---

        class Layer {
            constructor(type, id) {
                this.type = type;
                this.id = id;
                this.x = 1080 / 2;
                this.y = 1080 / 2;
                this.rotation = 0;
                this.scale = 1;
                this.opacity = 1;
                this.width = 0;
                this.height = 0;
                this.selected = false;
            }
            
            contains(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = dx * cos - dy * sin;
                const localY = dx * sin + dy * cos;
                
                // Allow selecting text even if small width
                const hitW = Math.max(20, this.width * this.scale);
                const hitH = Math.max(20, this.height * this.scale);

                return Math.abs(localX) < hitW / 2 && 
                       Math.abs(localY) < hitH / 2;
            }

            // Clone data for History
            serialize() {
                return {
                    type: this.type,
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    rotation: this.rotation,
                    scale: this.scale,
                    opacity: this.opacity,
                    width: this.width,
                    height: this.height
                };
            }
        }

        class ImageLayer extends Layer {
            constructor(img, id, existingCanvas = null) {
                super('image', id);
                this.originalImage = img;
                this.width = img.width;
                this.height = img.height;
                
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.ctx = this.canvas.getContext('2d');
                
                if (existingCanvas) {
                    this.ctx.drawImage(existingCanvas, 0, 0);
                } else if(img) {
                    this.ctx.drawImage(img, 0, 0);
                }
            }

            serialize() {
                const base = super.serialize();
                return {
                    ...base,
                    originalImage: this.originalImage,
                    imageData: this.ctx.getImageData(0, 0, this.width, this.height)
                };
            }
            
            replaceImage(newImg) {
                this.originalImage = newImg;
                const oldWidth = this.width;
                this.width = newImg.width;
                this.height = newImg.height;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.ctx.drawImage(newImg, 0, 0);
                
                if (oldWidth > 0) {
                     this.scale = this.scale * (oldWidth / this.width);
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;
                ctx.drawImage(this.canvas, -this.width/2, -this.height/2);
                ctx.restore();
            }

            erase(x, y, radius) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = (dx * cos - dy * sin) / this.scale + this.width/2;
                const localY = (dx * sin + dy * cos) / this.scale + this.height/2;

                this.ctx.save();
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.beginPath();
                this.ctx.arc(localX, localY, radius / this.scale, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            cropOutside(rect) {
                const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                
                for(let ly = 0; ly < this.height; ly++) {
                    for(let lx = 0; lx < this.width; lx++) {
                        const cx = lx - this.width/2;
                        const cy = ly - this.height/2;
                        
                        const sx = cx * this.scale;
                        const sy = cy * this.scale;
                        
                        const cos = Math.cos(this.rotation);
                        const sin = Math.sin(this.rotation);
                        
                        const gx = (sx * cos - sy * sin) + this.x;
                        const gy = (sx * sin + sy * cos) + this.y;
                        
                        // Check against Global Selection Rect
                        if (gx < rect.x || gx > rect.x + rect.w || gy < rect.y || gy > rect.y + rect.h) {
                            const idx = (ly * this.width + lx) * 4;
                            data[idx + 3] = 0; // Transparent
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.trim();
            }

            trim() {
                const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                const w = this.width;
                const h = this.height;

                let minX = w, minY = h, maxX = 0, maxY = 0;
                let found = false;

                // Find bounds of non-transparent pixels
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const alpha = data[(y * w + x) * 4 + 3];
                        if (alpha > 0) {
                            if (x < minX) minX = x;
                            if (x > maxX) maxX = x;
                            if (y < minY) minY = y;
                            if (y > maxY) maxY = y;
                            found = true;
                        }
                    }
                }

                if (!found) return; // Empty layer

                const trimW = maxX - minX + 1;
                const trimH = maxY - minY + 1;
                const trimmedData = this.ctx.getImageData(minX, minY, trimW, trimH);

                // Update Position to visually stay in same place
                const oldCX = w / 2;
                const oldCY = h / 2;
                const newCX = minX + trimW / 2;
                const newCY = minY + trimH / 2;

                const dx = (newCX - oldCX) * this.scale;
                const dy = (newCY - oldCY) * this.scale;
                const cos = Math.cos(this.rotation);
                const sin = Math.sin(this.rotation);

                this.x += dx * cos - dy * sin;
                this.y += dx * sin + dy * cos;

                // Resize internal canvas
                this.canvas.width = trimW;
                this.canvas.height = trimH;
                this.width = trimW;
                this.height = trimH;
                this.ctx.putImageData(trimmedData, 0, 0);
            }

            magicWand(x, y, tolerance) {
                this._performPixelOperation(x, y, tolerance, 'erase');
            }

            floodFill(x, y, colorHex, tolerance) {
                const r = parseInt(colorHex.slice(1, 3), 16);
                const g = parseInt(colorHex.slice(3, 5), 16);
                const b = parseInt(colorHex.slice(5, 7), 16);
                this._performPixelOperation(x, y, tolerance, 'fill', {r, g, b});
            }

            _performPixelOperation(x, y, tolerance, mode, fillColor = null) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = Math.floor((dx * cos - dy * sin) / this.scale + this.width/2);
                const localY = Math.floor((dx * sin + dy * cos) / this.scale + this.height/2);

                if(localX < 0 || localX >= this.width || localY < 0 || localY >= this.height) return;

                const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                const w = this.width;
                const h = this.height;

                const targetIdx = (localY * w + localX) * 4;
                const tr = data[targetIdx], tg = data[targetIdx+1], tb = data[targetIdx+2], ta = data[targetIdx+3];

                if(ta === 0 && mode === 'erase') return;
                if(mode === 'fill' && Math.abs(tr-fillColor.r) < 5 && Math.abs(tg-fillColor.g) < 5 && Math.abs(tb-fillColor.b) < 5) return;

                const stack = [[localX, localY]];
                const seen = new Uint8Array(w * h); 
                
                while(stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;

                    if(seen[cy * w + cx]) continue;
                    
                    const cr = data[idx], cg = data[idx+1], cb = data[idx+2], ca = data[idx+3];
                    const diff = Math.abs(cr - tr) + Math.abs(cg - tg) + Math.abs(cb - tb) + Math.abs(ca - ta);
                    
                    if (diff <= tolerance * 4) {
                        seen[cy * w + cx] = 1;
                        if(mode === 'erase') {
                            data[idx+3] = 0;
                        } else if (mode === 'fill') {
                            data[idx] = fillColor.r;
                            data[idx+1] = fillColor.g;
                            data[idx+2] = fillColor.b;
                            data[idx+3] = 255;
                        }
                        if(cx > 0) stack.push([cx-1, cy]);
                        if(cx < w-1) stack.push([cx+1, cy]);
                        if(cy > 0) stack.push([cx, cy-1]);
                        if(cy < h-1) stack.push([cx, cy+1]);
                    }
                }
                this.ctx.putImageData(imageData, 0, 0);
            }
        }

        class TextLayer extends Layer {
            constructor(text, id) {
                super('text', id);
                this.text = text || "Texto";
                this.fontFamily = 'Arial';
                this.fontSize = 60;
                this.color = '#ffffff';
                this.textTransform = 'none'; 
                this.boxWidth = 500; // Ancho por defecto para el wrapping
                this.measureDimensions();
            }

            serialize() {
                const base = super.serialize();
                return {
                    ...base,
                    text: this.text,
                    fontFamily: this.fontFamily,
                    fontSize: this.fontSize,
                    color: this.color,
                    textTransform: this.textTransform,
                    boxWidth: this.boxWidth
                };
            }

            getRenderText() {
                let t = this.text || " "; 
                if (this.textTransform === 'uppercase') return t.toUpperCase();
                if (this.textTransform === 'lowercase') return t.toLowerCase();
                return t;
            }

            getWrappedLines(ctx) {
                const text = this.getRenderText();
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = ctx.measureText(currentLine + " " + word).width;
                    if (width < this.boxWidth) {
                        currentLine += " " + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            measureDimensions() {
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                
                // Si el texto es vacio, dar dimensiones minimas
                if (!this.text || this.text.trim() === '') {
                    this.width = this.boxWidth;
                    this.height = this.fontSize;
                    return;
                }

                const lines = this.getWrappedLines(ctx);
                this.width = this.boxWidth;
                this.height = lines.length * this.fontSize * 1.2; // 1.2 es el line-height aproximado
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.fillStyle = this.color;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                
                const lines = this.getWrappedLines(ctx);
                const lineHeight = this.fontSize * 1.2;
                const totalHeight = lines.length * lineHeight;
                
                // Dibujar cada linea centrada
                lines.forEach((line, i) => {
                    const yOffset = (i * lineHeight) - (totalHeight / 2) + (lineHeight / 2);
                    ctx.fillText(line, 0, yOffset);
                });
                
                // Borde de guia si esta seleccionado (y vacio)
                if(this.selected && (!this.text || this.text.trim() === '')) {
                    ctx.strokeStyle = '#555';
                    ctx.setLineDash([2,2]);
                    ctx.strokeRect(-this.boxWidth/2, -this.fontSize/2, this.boxWidth, this.fontSize);
                }
                
                ctx.restore();
            }
        }

        // --- Core Application ---

        class EditorApp {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.layers = [];
                this.backgroundImage = null; // New Background Layer Slot
                this.history = [];
                this.historyMax = 15; 
                this.activeLayer = null;
                this.tool = 'move'; 
                this.zoom = 1;
                this.isDragging = false;
                this.isRotating = false;
                this.isResizing = false;
                
                this.isSelecting = false;
                this.selectionStart = {x:0, y:0};
                this.selectionRect = null; 
                
                this.showSafeZone = false; // State for Safe Zone Guide
                this.format = 'square'; // 'square' (1:1) or 'portrait' (4:5)

                this.lastMouse = { x: 0, y: 0 };
                this.bgColor = '#1a1a1a';
                this.hasUnsavedChanges = false;
                
                this.initEvents();
                this.initRulers();
                this.loop();
                this.saveState();
            }

            saveState() {
                const state = {
                    bgColor: this.bgColor,
                    format: this.format,
                    width: this.canvas.width,
                    height: this.canvas.height,
                    bgImage: this.backgroundImage, // Store reference to current bg image object
                    layers: this.layers.map(l => l.serialize())
                };

                this.history.push(state);
                if (this.history.length > this.historyMax) {
                    this.history.shift();
                }
                
                this.updateUndoButton();
                this.hasUnsavedChanges = false;
            }

            undo() {
                if (this.history.length <= 1) return;
                this.history.pop(); // Remove current state
                const prevState = this.history[this.history.length - 1];
                this.restoreState(prevState);
                this.updateUndoButton();
            }

            restoreState(state) {
                this.bgColor = state.bgColor;
                this.backgroundImage = state.bgImage; // Restore bg
                document.getElementById('bg-color').value = this.bgColor;
                
                // Restore format
                this.format = state.format || 'square';
                document.getElementById('canvas-format').value = this.format;
                
                if(state.width) {
                    this.canvas.width = state.width;
                    this.canvas.height = state.height;
                    this.initRulers();
                    document.getElementById('canvas-dims').innerText = `${state.width}x${state.height} px`;
                }
                
                this.layers = state.layers.map(data => {
                    let layer;
                    if (data.type === 'image') {
                        layer = new ImageLayer(data.originalImage, data.id);
                        if(data.imageData) layer.ctx.putImageData(data.imageData, 0, 0);
                    } else {
                        layer = new TextLayer(data.text, data.id);
                        layer.fontFamily = data.fontFamily;
                        layer.fontSize = data.fontSize;
                        layer.color = data.color;
                        layer.textTransform = data.textTransform || 'none';
                        layer.boxWidth = data.boxWidth || 500;
                    }
                    layer.x = data.x;
                    layer.y = data.y;
                    layer.rotation = data.rotation;
                    layer.scale = data.scale;
                    layer.opacity = data.opacity;
                    layer.width = data.width;
                    layer.height = data.height;
                    return layer;
                });

                this.setActiveLayer(null);
            }

            updateUndoButton() {
                const btn = document.getElementById('undo-btn');
                btn.disabled = this.history.length <= 1;
            }

            initEvents() {
                const workspace = document.getElementById('workspace');
                workspace.addEventListener('dragover', (e) => e.preventDefault());
                workspace.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const file = e.dataTransfer.files[0];
                    if(file && file.type.startsWith('image/')) {
                        this.saveState();
                        this.loadImage(file);
                    }
                });

                window.addEventListener('paste', (e) => {
                    const item = e.clipboardData.items[0];
                    if (item && item.type.indexOf("image") !== -1) {
                        this.saveState();
                        this.loadImage(item.getAsFile());
                    }
                });

                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                window.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: ()=>{} });
                }, {passive: false});

                document.getElementById('bg-color').addEventListener('change', (e) => {
                    this.bgColor = e.target.value;
                    this.saveState();
                });
                
                const propInputs = ['prop-opacity', 'prop-text-content', 'prop-font', 'prop-color', 'prop-text-width'];
                propInputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        this.handlePropertyChange(e);
                    });
                    document.getElementById(id).addEventListener('change', () => this.saveState());
                });
                
                window.addEventListener('keydown', (e) => {
                    // Prevenir que se borre la capa si estoy escribiendo en un input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    }
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if(this.activeLayer) {
                            this.saveState();
                            this.deleteLayer();
                        }
                    }
                    if (e.key === 'v') this.setTool('move');
                    if (e.key === 'e') this.setTool('eraser');
                    if (e.key === 'f') this.setTool('fill');
                    if (e.key === 'c') this.setTool('crop');
                });
            }
            
            changeFormat(newFormat) {
                this.saveState();
                this.format = newFormat;
                
                if (this.format === 'square') {
                    this.canvas.width = 1080;
                    this.canvas.height = 1080;
                } else if (this.format === 'portrait') {
                    this.canvas.width = 1080;
                    this.canvas.height = 1350;
                }
                
                document.getElementById('canvas-dims').innerText = `${this.canvas.width}x${this.canvas.height} px`;
                this.initRulers();
                
                // Adjust layers to center if needed? Or just leave them.
                // Keeping them is better usually.
            }

            initRulers() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const pxPerCm = 37.8;
                const totalCmW = w / pxPerCm;
                const totalCmH = h / pxPerCm;
                
                const hRuler = document.getElementById('ruler-h');
                const vRuler = document.getElementById('ruler-v');
                
                hRuler.innerHTML = '';
                vRuler.innerHTML = '';

                // Horizontal
                for(let i = 0; i <= Math.ceil(totalCmW); i++) {
                    const left = i * pxPerCm;
                    if(left > w + 50) break;

                    const tickMaj = document.createElement('div');
                    tickMaj.className = 'tick tick-h-major';
                    tickMaj.style.left = left + 'px';
                    hRuler.appendChild(tickMaj);
                    
                    const label = document.createElement('div');
                    label.className = 'tick-label label-h';
                    label.innerText = i;
                    label.style.left = left + 'px';
                    hRuler.appendChild(label);
                    
                    for(let j=1; j<10; j++) {
                        const tickMin = document.createElement('div');
                        tickMin.className = 'tick tick-h-minor';
                        tickMin.style.left = (left + j*(pxPerCm/10)) + 'px';
                        hRuler.appendChild(tickMin);
                    }
                }
                
                // Vertical
                for(let i = 0; i <= Math.ceil(totalCmH); i++) {
                    const top = i * pxPerCm;
                    if(top > h + 50) break;

                    const tickMaj = document.createElement('div');
                    tickMaj.className = 'tick tick-v-major';
                    tickMaj.style.top = top + 'px';
                    vRuler.appendChild(tickMaj);
                    
                    const label = document.createElement('div');
                    label.className = 'tick-label label-v';
                    label.innerText = i;
                    label.style.top = top + 'px';
                    vRuler.appendChild(label);
                    
                    for(let j=1; j<10; j++) {
                        const tickMin = document.createElement('div');
                        tickMin.className = 'tick tick-v-minor';
                        tickMin.style.top = (top + j*(pxPerCm/10)) + 'px';
                        vRuler.appendChild(tickMin);
                    }
                }
            }

            handlePropertyChange(e) {
                if(!this.activeLayer) return;
                const target = e.target;
                
                if(target.id === 'prop-opacity') this.activeLayer.opacity = target.value;
                if(target.id === 'prop-text-content' && this.activeLayer.type === 'text') {
                    this.activeLayer.text = target.value; 
                    this.activeLayer.measureDimensions();
                }
                if(target.id === 'prop-text-width' && this.activeLayer.type === 'text') {
                    this.activeLayer.boxWidth = parseInt(target.value);
                    this.activeLayer.measureDimensions();
                }
                if(target.id === 'prop-font' && this.activeLayer.type === 'text') {
                    const [family, transform] = target.value.split('|');
                    this.activeLayer.fontFamily = family;
                    this.activeLayer.textTransform = transform || 'none';
                    this.activeLayer.measureDimensions();
                }
                if(target.id === 'prop-color' && this.activeLayer.type === 'text') {
                    this.activeLayer.color = target.value;
                }
            }

            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width, h = img.height;
                        const maxD = Math.max(this.canvas.width, this.canvas.height) * 1.5;
                        if(w > maxD || h > maxD) {
                            const ratio = Math.min(maxD/w, maxD/h);
                            w *= ratio; h *= ratio;
                        }
                        const layer = new ImageLayer(img, Date.now());
                        // Fit to canvas
                        if(layer.width > this.canvas.width) {
                            layer.scale = this.canvas.width / layer.width * 0.8;
                        }
                        layer.x = this.canvas.width / 2;
                        layer.y = this.canvas.height / 2;
                        
                        this.addLayer(layer);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            handleImageReplace(input) {
                 if (input.files && input.files[0] && this.activeLayer && this.activeLayer.type === 'image') {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            this.saveState();
                            this.activeLayer.replaceImage(img);
                            input.value = '';
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(input.files[0]);
                }
            }

            handleBackgroundUpload(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            this.saveState();
                            this.backgroundImage = img;
                            input.value = '';
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(input.files[0]);
                }
            }

            clearBackground() {
                this.saveState();
                this.backgroundImage = null;
            }

            addTextLayer() {
                this.saveState();
                const layer = new TextLayer('Nuevo Texto', Date.now());
                layer.x = this.canvas.width / 2;
                layer.y = this.canvas.height / 2;
                this.addLayer(layer);
                this.setTool('move');
            }

            addLayer(layer) {
                this.layers.push(layer);
                this.setActiveLayer(layer);
                this.saveState();
            }

            deleteLayer() {
                if(!this.activeLayer) return;
                this.layers = this.layers.filter(l => l !== this.activeLayer);
                this.setActiveLayer(null);
                this.saveState();
            }

            reorderLayer(direction) {
                if(!this.activeLayer) return;
                const idx = this.layers.indexOf(this.activeLayer);
                if(direction === 'up' && idx < this.layers.length - 1) {
                    [this.layers[idx], this.layers[idx+1]] = [this.layers[idx+1], this.layers[idx]];
                    this.saveState();
                } else if (direction === 'down' && idx > 0) {
                    [this.layers[idx], this.layers[idx-1]] = [this.layers[idx-1], this.layers[idx]];
                    this.saveState();
                }
            }
            
            centerLayer() {
                if(this.activeLayer) {
                    this.saveState();
                    this.activeLayer.x = this.canvas.width / 2;
                    this.activeLayer.y = this.canvas.height / 2;
                    this.saveState();
                }
            }

            setActiveLayer(layer) {
                if(this.activeLayer) this.activeLayer.selected = false;
                this.activeLayer = layer;
                if(layer) layer.selected = true;
                this.updatePropertiesPanel();
            }

            setTool(name) {
                this.tool = name;
                this.selectionRect = null; 
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                const btn = document.getElementById(`tool-${name}`);
                if(btn) btn.classList.add('active');
                
                const toolSettings = document.getElementById('tool-settings');
                const eraserSet = document.getElementById('eraser-settings');
                const wandSet = document.getElementById('wand-settings');
                const fillSet = document.getElementById('fill-settings');
                const cropSet = document.getElementById('crop-settings');
                
                toolSettings.style.display = (['eraser', 'magic-wand', 'fill', 'crop'].includes(name)) ? 'block' : 'none';
                
                eraserSet.style.display = name === 'eraser' ? 'block' : 'none';
                wandSet.style.display = name === 'magic-wand' ? 'block' : 'none';
                fillSet.style.display = name === 'fill' ? 'block' : 'none';
                cropSet.style.display = name === 'crop' ? 'block' : 'none';
            }
            
            setZoom(val) {
                this.zoom = parseFloat(val);
                const container = document.getElementById('canvas-wrapper');
                container.style.transform = `scale(${this.zoom})`;
                document.getElementById('zoom-level').innerText = Math.round(this.zoom * 100) + '%';
            }
            
            toggleSafeZone() {
                this.showSafeZone = !this.showSafeZone;
                const btn = document.getElementById('safe-zone-btn');
                if(this.showSafeZone) btn.classList.add('active-tool');
                else btn.classList.remove('active-tool');
            }

            updatePropertiesPanel() {
                const noSel = document.getElementById('no-selection-msg');
                const props = document.getElementById('layer-properties');
                
                if(!this.activeLayer) {
                    noSel.style.display = 'block';
                    props.style.display = 'none';
                    return;
                }
                
                noSel.style.display = 'none';
                props.style.display = 'block';
                
                const textControls = document.getElementById('text-controls');
                const imgControls = document.getElementById('image-controls');
                document.getElementById('prop-opacity').value = this.activeLayer.opacity;
                
                if(this.activeLayer.type === 'text') {
                    textControls.style.display = 'block';
                    imgControls.style.display = 'none';
                    document.getElementById('prop-text-content').value = this.activeLayer.text || "";
                    document.getElementById('prop-text-width').value = this.activeLayer.boxWidth; // Update width slider
                    
                    let val = this.activeLayer.fontFamily;
                    if (this.activeLayer.textTransform && this.activeLayer.textTransform !== 'none') {
                        val += '|' + this.activeLayer.textTransform;
                    }
                    const select = document.getElementById('prop-font');
                    if ([...select.options].some(o => o.value === val)) {
                        select.value = val;
                    } else {
                        select.value = this.activeLayer.fontFamily;
                    }
                    document.getElementById('prop-color').value = this.activeLayer.color;
                } else {
                    textControls.style.display = 'none';
                    imgControls.style.display = 'block';
                }
            }

            getMousePos(evt) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.lastMouse = pos;
                
                if (this.tool === 'move') {
                    if(this.activeLayer && this.activeLayer.selected) {
                        if (this.checkRotationHandle(pos)) {
                            this.isRotating = true; return;
                        }
                        if (this.checkResizeHandle(pos)) {
                            this.isResizing = true; return;
                        }
                    }

                    let clickedLayer = null;
                    for(let i = this.layers.length - 1; i >= 0; i--) {
                        if(this.layers[i].contains(pos.x, pos.y)) {
                            clickedLayer = this.layers[i];
                            break;
                        }
                    }

                    if(clickedLayer) {
                        this.setActiveLayer(clickedLayer);
                        this.isDragging = true;
                    } else {
                        this.setActiveLayer(null);
                    }
                } else if (this.tool === 'crop') {
                    this.isSelecting = true;
                    this.selectionStart = pos;
                    this.selectionRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
                } else if (this.activeLayer && this.activeLayer.type === 'image') {
                    if (this.tool === 'eraser') {
                        const size = parseInt(document.getElementById('eraser-size').value);
                        this.activeLayer.erase(pos.x, pos.y, size);
                        this.isDragging = true; 
                        this.hasUnsavedChanges = true;
                    } else if (this.tool === 'magic-wand') {
                        this.saveState(); 
                        const tol = parseInt(document.getElementById('wand-tol').value);
                        this.activeLayer.magicWand(pos.x, pos.y, tol);
                        this.saveState(); 
                    } else if (this.tool === 'fill') {
                        this.saveState(); 
                        const tol = parseInt(document.getElementById('fill-tol').value);
                        const color = document.getElementById('fill-color').value;
                        this.activeLayer.floodFill(pos.x, pos.y, color, tol);
                        this.saveState();
                    }
                }
            }

            handleMouseMove(e) {
                const pos = this.getMousePos(e);

                if (this.tool === 'move') {
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;

                    if (this.isDragging && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        let nx = this.activeLayer.x + (pos.x - this.lastMouse.x);
                        let ny = this.activeLayer.y + (pos.y - this.lastMouse.y);
                        
                        // Snap to center
                        if (Math.abs(nx - cx) < 10) nx = cx;
                        if (Math.abs(ny - cy) < 10) ny = cy;

                        this.activeLayer.x = nx;
                        this.activeLayer.y = ny;
                    } else if (this.isRotating && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        const dx = pos.x - this.activeLayer.x;
                        const dy = pos.y - this.activeLayer.y;
                        this.activeLayer.rotation = Math.atan2(dy, dx) + Math.PI / 2;
                    } else if (this.isResizing && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        const dx = pos.x - this.activeLayer.x;
                        const dy = pos.y - this.activeLayer.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const baseSize = Math.sqrt(Math.pow(this.activeLayer.width/2, 2) + Math.pow(this.activeLayer.height/2, 2));
                        this.activeLayer.scale = dist / baseSize;
                    }
                } else if (this.tool === 'crop' && this.isSelecting) {
                    const w = pos.x - this.selectionStart.x;
                    const h = pos.y - this.selectionStart.y;
                    this.selectionRect = {
                        x: w > 0 ? this.selectionStart.x : pos.x,
                        y: h > 0 ? this.selectionStart.y : pos.y,
                        w: Math.abs(w),
                        h: Math.abs(h)
                    };
                } else if (this.tool === 'eraser' && this.isDragging && this.activeLayer) {
                    const size = parseInt(document.getElementById('eraser-size').value);
                    this.activeLayer.erase(pos.x, pos.y, size);
                }

                this.lastMouse = pos;
            }

            handleMouseUp() {
                this.isDragging = false;
                this.isRotating = false;
                this.isResizing = false;
                
                if (this.tool === 'crop' && this.isSelecting) {
                    this.isSelecting = false;
                    // Apply crop ONLY to active layer if it's an image
                    if(this.selectionRect && this.selectionRect.w > 10 && this.selectionRect.h > 10 && this.activeLayer && this.activeLayer.type === 'image') {
                        this.saveState();
                        this.activeLayer.cropOutside(this.selectionRect);
                        this.saveState();
                        this.selectionRect = null;
                        this.setTool('move');
                    } else {
                        // Cancel if invalid selection or no layer
                        this.selectionRect = null;
                    }
                }

                if (this.hasUnsavedChanges) {
                    this.saveState();
                    this.hasUnsavedChanges = false;
                }
            }
            
            // Removed cropCanvas(rect) method as requested to keep 1080x1080 fixed

            checkRotationHandle(pos) {
                const l = this.activeLayer;
                const cx = l.x + Math.sin(l.rotation) * (l.height * l.scale / 2 + 40);
                const cy = l.y - Math.cos(l.rotation) * (l.height * l.scale / 2 + 40);
                return Math.abs(pos.x - cx) < 10 && Math.abs(pos.y - cy) < 10;
            }

            checkResizeHandle(pos) {
                const l = this.activeLayer;
                const cos = Math.cos(l.rotation);
                const sin = Math.sin(l.rotation);
                const dx = l.width/2 * l.scale;
                const dy = l.height/2 * l.scale;
                const cx = l.x + dx*cos - dy*sin;
                const cy = l.y + dx*sin + dy*cos;
                return Math.abs(pos.x - cx) < 15 && Math.abs(pos.y - cy) < 15;
            }

            drawUI(ctx) {
                const cw = this.canvas.width;
                const ch = this.canvas.height;
                
                // Safe Zone (Guides)
                if (this.showSafeZone) {
                    ctx.save();
                    const margin = 60; // Margin for text/logos (Safe Zone)

                    if (this.format === 'square') {
                        // Square Mode: Inner Margin
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                        ctx.beginPath();
                        ctx.rect(0, 0, cw, ch);
                        ctx.rect(cw - margin, margin, -(cw - margin*2), ch - margin*2); 
                        ctx.fill('evenodd');

                        ctx.strokeStyle = '#ff0000'; // Bright Red
                        ctx.lineWidth = 2;
                        ctx.setLineDash([8, 8]);
                        ctx.strokeRect(margin, margin, cw - margin*2, ch - margin*2);
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 14px sans-serif';
                        ctx.fillText("ZONA SEGURA (MÁRGENES)", margin + 10, margin - 10);
                        
                    } else if (this.format === 'portrait') {
                        // Portrait Mode: Top/Bottom Crops
                        const cropH = 135; // 135px top and bottom
                        
                        // 1. Darken Top and Bottom (Danger Zone for Profile)
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Darker for better contrast
                        ctx.fillRect(0, 0, cw, cropH); 
                        ctx.fillRect(0, ch - cropH, cw, cropH); 
                        
                        // 2. Outline The Profile Square (1080x1080 Center)
                        ctx.strokeStyle = '#00ffff'; // Cyan for Grid Cutoff
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(0, cropH, cw, ch - cropH*2);

                        // 3. Draw Inner Safe Zone (Text Safety) relative to the Square
                        // The square starts at y = cropH.
                        // We want margins inside that square.
                        ctx.strokeStyle = '#ff00ff'; // Magenta for Text Safe Zone
                        ctx.setLineDash([8, 8]);
                        ctx.strokeRect(margin, cropH + margin, cw - margin*2, (ch - cropH*2) - margin*2);

                        // Text indicators
                        ctx.fillStyle = '#00ffff';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillText("LÍMITE PERFIL (GRID)", 10, cropH - 10);
                        
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillText("ZONA SEGURA TEXTO", margin + 10, cropH + margin + 20);
                    }
                    
                    ctx.restore();
                }

                // Draw Selection Rect (Crop)
                if (this.tool === 'crop' && this.selectionRect) {
                    ctx.save();
                    ctx.strokeStyle = '#00ff9d';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(this.selectionRect.x, this.selectionRect.y, this.selectionRect.w, this.selectionRect.h);
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.beginPath();
                    ctx.rect(0, 0, cw, ch);
                    ctx.rect(this.selectionRect.x + this.selectionRect.w, this.selectionRect.y, -this.selectionRect.w, this.selectionRect.h);
                    ctx.fill('evenodd');
                    ctx.restore();
                }

                if(!this.activeLayer || !this.activeLayer.selected) return;
                
                const l = this.activeLayer;

                if (this.isDragging && this.tool === 'move') {
                    this.drawSmartGuides(ctx, l);
                }

                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rotation);
                
                ctx.strokeStyle = '#00ff9d';
                ctx.lineWidth = 2;
                const w = l.width * l.scale;
                const h = l.height * l.scale;
                ctx.strokeRect(-w/2, -h/2, w, h);
                
                ctx.beginPath();
                ctx.moveTo(0, -h/2);
                ctx.lineTo(0, -h/2 - 40);
                ctx.stroke();

                ctx.fillStyle = '#00ff9d';
                ctx.beginPath();
                ctx.arc(0, -h/2 - 40, 6, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(w/2, h/2, 6, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
                
                if(this.tool === 'eraser') {
                    const size = parseInt(document.getElementById('eraser-size').value);
                    const mouse = this.lastMouse;
                    ctx.save();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(mouse.x, mouse.y, size, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            drawSmartGuides(ctx, layer) {
                const cx = layer.x;
                const cy = layer.y;
                const centerSnap = 10;
                
                ctx.save();
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#ff00ff';
                
                const canvasCX = this.canvas.width / 2;
                const canvasCY = this.canvas.height / 2;

                // 1. Center of Canvas Guides
                if (Math.abs(cx - canvasCX) < centerSnap) {
                    ctx.beginPath(); ctx.moveTo(canvasCX, 0); ctx.lineTo(canvasCX, this.canvas.height); ctx.stroke();
                }
                if (Math.abs(cy - canvasCY) < centerSnap) {
                    ctx.beginPath(); ctx.moveTo(0, canvasCY); ctx.lineTo(this.canvas.width, canvasCY); ctx.stroke();
                }

                // 2. Alignment with OTHER layers
                this.layers.forEach(other => {
                    if (other === layer) return;
                    
                    // Snap to other Center X
                    if (Math.abs(cx - other.x) < centerSnap) {
                        ctx.beginPath(); ctx.moveTo(other.x, Math.min(cy, other.y)); ctx.lineTo(other.x, Math.max(cy, other.y)); ctx.stroke();
                    }
                    // Snap to other Center Y
                    if (Math.abs(cy - other.y) < centerSnap) {
                        ctx.beginPath(); ctx.moveTo(Math.min(cx, other.x), other.y); ctx.lineTo(Math.max(cx, other.x), other.y); ctx.stroke();
                    }
                });

                // Distance Labels
                ctx.fillText(`x: ${Math.round(cx)}`, cx + 10, cy - 10);
                ctx.fillText(`y: ${Math.round(cy)}`, cx + 10, cy + 10);

                ctx.restore();
            }

            loop() {
                // 1. Background
                if(this.backgroundImage) {
                    // Calculate "cover" scale
                    const ratio = Math.max(this.canvas.width / this.backgroundImage.width, this.canvas.height / this.backgroundImage.height);
                    const cw = this.backgroundImage.width * ratio;
                    const ch = this.backgroundImage.height * ratio;
                    const cx = (this.canvas.width - cw) / 2;
                    const cy = (this.canvas.height - ch) / 2;
                    this.ctx.drawImage(this.backgroundImage, cx, cy, cw, ch);
                } else {
                    this.ctx.fillStyle = this.bgColor;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                // 2. Layers
                this.layers.forEach(layer => layer.draw(this.ctx));
                this.drawUI(this.ctx);
                requestAnimationFrame(this.loop.bind(this));
            }

            handleImageUpload(input) {
                if (input.files && input.files[0]) {
                    this.saveState();
                    this.loadImage(input.files[0]);
                }
            }

            exportImage() {
                const prevSelection = this.activeLayer;
                const wasSelecting = this.tool === 'crop' && this.selectionRect;
                if(wasSelecting) this.selectionRect = null;

                this.setActiveLayer(null);
                
                // Force Redraw for clean export
                if(this.backgroundImage) {
                    const ratio = Math.max(this.canvas.width / this.backgroundImage.width, this.canvas.height / this.backgroundImage.height);
                    const cw = this.backgroundImage.width * ratio;
                    const ch = this.backgroundImage.height * ratio;
                    const cx = (this.canvas.width - cw) / 2;
                    const cy = (this.canvas.height - ch) / 2;
                    this.ctx.drawImage(this.backgroundImage, cx, cy, cw, ch);
                } else {
                    this.ctx.fillStyle = this.bgColor;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                this.layers.forEach(layer => layer.draw(this.ctx));
                
                const format = document.getElementById('export-format').value;
                const link = document.createElement('a');
                link.download = `ecopiensa-design.${format.split('/')[1]}`;
                link.href = this.canvas.toDataURL(format, 0.9);
                link.click();

                this.setActiveLayer(prevSelection);
            }

            toggleGridPreview() {
                const modal = document.getElementById('preview-modal');
                const isOpen = modal.classList.contains('open');
                
                if(!isOpen) {
                    const prevSelection = this.activeLayer;
                    this.setActiveLayer(null);
                    
                    // Render for preview
                    if(this.backgroundImage) {
                        const ratio = Math.max(this.canvas.width / this.backgroundImage.width, this.canvas.height / this.backgroundImage.height);
                        const cw = this.backgroundImage.width * ratio;
                        const ch = this.backgroundImage.height * ratio;
                        const cx = (this.canvas.width - cw) / 2;
                        const cy = (this.canvas.height - ch) / 2;
                        this.ctx.drawImage(this.backgroundImage, cx, cy, cw, ch);
                    } else {
                        this.ctx.fillStyle = this.bgColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    this.layers.forEach(layer => layer.draw(this.ctx));
                    
                    document.getElementById('preview-img').src = this.canvas.toDataURL();
                    this.setActiveLayer(prevSelection);
                    modal.classList.add('open');
                } else {
                    modal.classList.remove('open');
                }
            }

            handleProfilePic(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const url = `url(${e.target.result})`;
                        document.getElementById('prev-avatar').style.backgroundImage = url;
                    };
                    reader.readAsDataURL(input.files[0]);
                }
            }

            updateProfilePreview() {
                const name = document.getElementById('profile-name').value;
                const caption = document.getElementById('profile-caption').value;
                
                document.getElementById('prev-username').innerText = name;
                document.getElementById('prev-username-cap').innerText = name;
                document.getElementById('prev-caption-text').innerText = caption;
            }
        }

        window.app = new EditorApp();
        
        document.getElementById('eraser-size').addEventListener('input', (e) => {
            document.getElementById('eraser-size-val').innerText = e.target.value;
        });
        document.getElementById('wand-tol').addEventListener('input', (e) => {
            document.getElementById('wand-tol-val').innerText = e.target.value;
        });
        document.getElementById('fill-tol').addEventListener('input', (e) => {
            document.getElementById('fill-tol-val').innerText = e.target.value;
        });

    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecopiensa Editor | Instagram Composer</title>
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --bg-hover: #2d2d2d;
            --accent: #00ff9d;
            --text-main: #ffffff;
            --text-muted: #a0a0a0;
            --border: #333;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-rows: 60px 1fr;
            grid-template-columns: 70px 1fr 300px;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            grid-column: 1 / -1;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .logo { font-weight: 700; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .logo span { color: var(--accent); }

        .header-controls { display: flex; gap: 15px; align-items: center; }

        button {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        button:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        button.primary { background: var(--accent); color: #000; font-weight: 600; border: none; }
        button.primary:hover:not(:disabled) { opacity: 0.9; }

        /* --- Toolbar Left --- */
        .toolbar {
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 15px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-muted);
            border: 1px solid transparent;
            position: relative;
        }

        .tool-btn:hover { background: var(--bg-hover); color: var(--text-main); }
        .tool-btn.active { background: rgba(0, 255, 157, 0.1); color: var(--accent); border-color: var(--accent); }
        .tool-tooltip {
            position: absolute; left: 120%; background: #000; padding: 5px 10px; 
            border-radius: 4px; font-size: 0.8rem; pointer-events: none; opacity: 0; transition: opacity 0.2s; white-space: nowrap; z-index: 10;
        }
        .tool-btn:hover .tool-tooltip { opacity: 1; }

        /* --- Canvas Area --- */
        .workspace {
            background-color: #0a0a0a;
            background-image: radial-gradient(#222 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        #canvas-container {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transition: transform 0.1s;
        }

        canvas { display: block; background: #1a1a1a; cursor: crosshair; }

        /* --- Properties Panel Right --- */
        .properties {
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section { margin-bottom: 25px; }
        .panel-title { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 10px; font-weight: 700; }

        .control-group { margin-bottom: 15px; }
        .control-label { display: block; font-size: 0.9rem; margin-bottom: 5px; }
        
        input[type="text"], input[type="number"], select {
            width: 100%; background: var(--bg-dark); border: 1px solid var(--border); color: var(--text-main);
            padding: 8px; border-radius: 4px; outline: none;
        }
        input:focus { border-color: var(--accent); }

        input[type="range"] { width: 100%; accent-color: var(--accent); }
        
        .layer-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        /* --- Instagram Preview Modal --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100; display: none;
            justify-content: center; align-items: center;
        }
        .modal-overlay.open { display: flex; }
        
        .modal-content {
            display: flex;
            gap: 20px;
            background: #151515;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        .ig-preview {
            background: #000; width: 375px; height: 700px; border-radius: 20px;
            border: 8px solid #333; overflow: hidden; position: relative;
            display: flex; flex-direction: column;
            flex-shrink: 0;
        }
        .ig-header { height: 50px; border-bottom: 1px solid #333; display: flex; align-items: center; padding: 0 15px; font-size: 0.9rem; font-weight: bold; }
        .ig-avatar { width: 30px; height: 30px; border-radius: 50%; background: #555; margin-right: 10px; background-size: cover; background-position: center; }
        .ig-content { width: 100%; aspect-ratio: 1/1; background: #222; margin-top: 10px; }
        .ig-content img { width: 100%; height: 100%; object-fit: contain; }
        .ig-actions { padding: 10px 15px; display: flex; gap: 15px; }
        .ig-caption { padding: 0 15px; font-size: 0.85rem; color: #eee; }
        .close-modal { position: absolute; top: -15px; right: -15px; color: white; cursor: pointer; background: #333; border-radius: 50%; padding: 5px; }
        
        /* Profile Editor in Modal */
        .profile-editor {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .profile-editor h3 { font-size: 1rem; color: var(--accent); margin-bottom: 10px; }

        /* Responsive */
        @media (max-width: 900px) {
            .modal-content { flex-direction: column; max-height: 90vh; overflow-y: auto; }
        }
        @media (max-width: 768px) {
            body { grid-template-columns: 50px 1fr; grid-template-rows: 50px 1fr 200px; }
            .properties { grid-column: 1 / -1; border-top: 1px solid var(--border); border-left: none; }
            .header-controls span { display: none; }
        }
    </style>
</head>
<body>

    <!-- Header -->
    <header>
        <div class="logo">
            <i data-lucide="layout-grid"></i>
            Ecopiensa<span>Editor</span>
        </div>
        <div class="header-controls">
            <!-- Undo Button -->
            <button onclick="app.undo()" id="undo-btn" title="Deshacer (Ctrl+Z)" disabled>
                <i data-lucide="undo-2"></i> <span>Deshacer</span>
            </button>
            
            <div style="width: 1px; height: 20px; background: #333; margin: 0 5px;"></div>

            <div class="zoom-controls">
                <button onclick="app.setZoom(-0.1)"><i data-lucide="minus"></i></button>
                <span id="zoom-level">100%</span>
                <button onclick="app.setZoom(0.1)"><i data-lucide="plus"></i></button>
            </div>
            <button onclick="app.toggleGridPreview()"><i data-lucide="eye"></i> <span>Vista Previa</span></button>
            <select id="export-format" style="width: auto;">
                <option value="image/png">PNG</option>
                <option value="image/jpeg">JPG</option>
                <option value="image/webp">WebP</option>
            </select>
            <button class="primary" onclick="app.exportImage()"><i data-lucide="download"></i> <span>Exportar</span></button>
        </div>
    </header>

    <!-- Toolbar -->
    <aside class="toolbar">
        <button class="tool-btn active" onclick="app.setTool('move')" id="tool-move">
            <i data-lucide="move"></i><span class="tool-tooltip">Mover/Seleccionar (V)</span>
        </button>
        <button class="tool-btn" onclick="document.getElementById('file-upload').click()">
            <i data-lucide="image-plus"></i><span class="tool-tooltip">Añadir Imagen</span>
        </button>
        <button class="tool-btn" onclick="app.addTextLayer()">
            <i data-lucide="type"></i><span class="tool-tooltip">Añadir Texto (T)</span>
        </button>
        <div style="height: 1px; width: 30px; background: #333; margin: 5px 0;"></div>
        <button class="tool-btn" onclick="app.setTool('eraser')" id="tool-eraser">
            <i data-lucide="eraser"></i><span class="tool-tooltip">Borrador (E)</span>
        </button>
        <button class="tool-btn" onclick="app.setTool('magic-wand')" id="tool-magic-wand">
            <i data-lucide="wand-2"></i><span class="tool-tooltip">Varita Mágica (W)</span>
        </button>
        <button class="tool-btn" onclick="app.setTool('fill')" id="tool-fill">
            <i data-lucide="paint-bucket"></i><span class="tool-tooltip">Relleno (F)</span>
        </button>
        <input type="file" id="file-upload" accept="image/*" hidden onchange="app.handleImageUpload(this)">
    </aside>

    <!-- Workspace -->
    <main class="workspace" id="workspace">
        <div id="canvas-container">
            <canvas id="main-canvas" width="1080" height="1080"></canvas>
        </div>
    </main>

    <!-- Properties Panel -->
    <aside class="properties" id="properties-panel">
        <div class="panel-section">
            <div class="panel-title">Lienzo</div>
            <div class="control-group">
                <label class="control-label">Color de Fondo</label>
                <input type="color" id="bg-color" value="#1a1a1a" style="height: 40px; width: 100%;">
            </div>
        </div>

        <div id="layer-properties" style="display:none;">
            <div class="panel-section">
                <div class="panel-title" id="prop-title">Propiedades de Capa</div>
                
                <!-- Text Controls -->
                <div id="text-controls" style="display:none;">
                    <div class="control-group">
                        <label class="control-label">Contenido</label>
                        <input type="text" id="prop-text-content">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Fuente</label>
                        <select id="prop-font">
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Impact">Impact</option>
                            <option value="Brush Script MT">Brush Script</option>
                            <option disabled>───────</option>
                            <option value="Roboto Slab">Slab Serif</option>
                            <option value="Roboto Slab|uppercase">Slab Serif (Mayúsculas)</option>
                            <option value="Roboto Slab|lowercase">Slab Serif (Minúsculas)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Color</label>
                        <input type="color" id="prop-color" style="height: 40px;">
                    </div>
                </div>

                <!-- Transform Controls -->
                <div class="control-group">
                    <label class="control-label">Opacidad</label>
                    <input type="range" id="prop-opacity" min="0" max="1" step="0.01">
                </div>

                <!-- Ordering/Actions -->
                <div class="panel-title" style="margin-top: 20px;">Acciones</div>
                <div class="layer-actions">
                    <button onclick="app.reorderLayer('up')"><i data-lucide="arrow-up"></i> Subir</button>
                    <button onclick="app.reorderLayer('down')"><i data-lucide="arrow-down"></i> Bajar</button>
                    <button onclick="app.centerLayer()"><i data-lucide="align-center"></i> Centrar</button>
                    <button onclick="app.deleteLayer()" style="background: #ff4444; color: white; border: none;"><i data-lucide="trash-2"></i></button>
                </div>
            </div>
            
            <!-- Tool Specific Settings -->
            <div id="tool-settings" class="panel-section" style="display:none; border-top: 1px solid #333; padding-top: 20px;">
                <div class="panel-title">Ajustes de Herramienta</div>
                
                <div id="eraser-settings" style="display:none;">
                    <label class="control-label">Tamaño Borrador: <span id="eraser-size-val">20</span>px</label>
                    <input type="range" id="eraser-size" min="5" max="100" value="20">
                </div>
                
                <div id="wand-settings" style="display:none;">
                    <label class="control-label">Tolerancia: <span id="wand-tol-val">30</span></label>
                    <input type="range" id="wand-tol" min="0" max="100" value="30">
                </div>

                <div id="fill-settings" style="display:none;">
                    <label class="control-label">Color de Relleno</label>
                    <input type="color" id="fill-color" value="#00ff9d" style="height: 40px; width: 100%; margin-bottom: 10px;">
                    <label class="control-label">Tolerancia: <span id="fill-tol-val">30</span></label>
                    <input type="range" id="fill-tol" min="0" max="100" value="30">
                </div>
            </div>
        </div>
        
        <div id="no-selection-msg" style="color: #666; font-style: italic; text-align: center; margin-top: 20px;">
            Selecciona un objeto para editar sus propiedades.
        </div>
    </aside>

    <!-- Preview & Profile Settings Modal -->
    <div class="modal-overlay" id="preview-modal">
        <div style="position: relative;">
            <div class="close-modal" onclick="app.toggleGridPreview()"><i data-lucide="x" size="24"></i></div>
            
            <div class="modal-content">
                <!-- Phone Preview -->
                <div class="ig-preview">
                    <div class="ig-header">
                        <div class="ig-avatar" id="prev-avatar"></div>
                        <span id="prev-username">ecopiensa_oficial</span>
                    </div>
                    <div class="ig-content">
                        <img id="preview-img" src="">
                    </div>
                    <div class="ig-actions">
                        <i data-lucide="heart"></i>
                        <i data-lucide="message-circle"></i>
                        <i data-lucide="send"></i>
                    </div>
                    <div class="ig-caption">
                        <strong id="prev-username-cap">ecopiensa_oficial</strong> <span id="prev-caption-text">Nueva composición creada con Ecopiensa Editor. #design #eco #instagram</span>
                    </div>
                </div>

                <!-- Profile Editor Sidebar -->
                <div class="profile-editor">
                    <h3>Personalizar Perfil</h3>
                    <div class="control-group">
                        <label class="control-label">Usuario Instagram</label>
                        <input type="text" id="profile-name" value="ecopiensa_oficial" oninput="app.updateProfilePreview()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Foto de Perfil</label>
                        <input type="file" id="profile-pic-input" accept="image/*" style="display:none" onchange="app.handleProfilePic(this)">
                        <button onclick="document.getElementById('profile-pic-input').click()" style="width: 100%;">
                            <i data-lucide="upload"></i> Subir Foto
                        </button>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Texto del Post</label>
                        <textarea id="profile-caption" rows="4" oninput="app.updateProfilePreview()" style="width: 100%; background: #121212; color: white; border: 1px solid #333; padding: 8px; border-radius: 4px;">Nueva composición creada con Ecopiensa Editor. #design #eco #instagram</textarea>
                    </div>
                    <div style="margin-top: auto; font-size: 0.8rem; color: #777;">
                        <i data-lucide="info" size="14" style="vertical-align: middle;"></i> 
                        La API de Instagram no permite publicar directamente desde la web. Personaliza aquí tu vista previa y luego usa "Exportar" para subir la imagen manualmente.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Application Logic -->
    <script type="module">
        lucide.createIcons();

        // --- Clases Principales ---

        class Layer {
            constructor(type, id) {
                this.type = type;
                this.id = id;
                this.x = 1080 / 2;
                this.y = 1080 / 2;
                this.rotation = 0;
                this.scale = 1;
                this.opacity = 1;
                this.width = 0;
                this.height = 0;
                this.selected = false;
            }
            
            contains(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = dx * cos - dy * sin;
                const localY = dx * sin + dy * cos;
                
                return Math.abs(localX) < (this.width * this.scale) / 2 && 
                       Math.abs(localY) < (this.height * this.scale) / 2;
            }

            // Clone data for History
            serialize() {
                return {
                    type: this.type,
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    rotation: this.rotation,
                    scale: this.scale,
                    opacity: this.opacity,
                    width: this.width,
                    height: this.height
                };
            }
        }

        class ImageLayer extends Layer {
            constructor(img, id, existingCanvas = null) {
                super('image', id);
                this.originalImage = img;
                this.width = img.width;
                this.height = img.height;
                
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.ctx = this.canvas.getContext('2d');
                
                if (existingCanvas) {
                    this.ctx.drawImage(existingCanvas, 0, 0);
                } else {
                    this.ctx.drawImage(img, 0, 0);
                }
            }

            serialize() {
                const base = super.serialize();
                // Important: We need a copy of the pixel data for Undo to work with eraser/fill
                return {
                    ...base,
                    originalImage: this.originalImage,
                    imageData: this.ctx.getImageData(0, 0, this.width, this.height)
                };
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;
                ctx.drawImage(this.canvas, -this.width/2, -this.height/2);
                ctx.restore();
            }

            erase(x, y, radius) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = (dx * cos - dy * sin) / this.scale + this.width/2;
                const localY = (dx * sin + dy * cos) / this.scale + this.height/2;

                this.ctx.save();
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.beginPath();
                this.ctx.arc(localX, localY, radius / this.scale, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            magicWand(x, y, tolerance) {
                this._performPixelOperation(x, y, tolerance, 'erase');
            }

            floodFill(x, y, colorHex, tolerance) {
                // Convert hex to rgb
                const r = parseInt(colorHex.slice(1, 3), 16);
                const g = parseInt(colorHex.slice(3, 5), 16);
                const b = parseInt(colorHex.slice(5, 7), 16);
                this._performPixelOperation(x, y, tolerance, 'fill', {r, g, b});
            }

            _performPixelOperation(x, y, tolerance, mode, fillColor = null) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const localX = Math.floor((dx * cos - dy * sin) / this.scale + this.width/2);
                const localY = Math.floor((dx * sin + dy * cos) / this.scale + this.height/2);

                if(localX < 0 || localX >= this.width || localY < 0 || localY >= this.height) return;

                const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                const w = this.width;
                const h = this.height;

                const targetIdx = (localY * w + localX) * 4;
                const tr = data[targetIdx], tg = data[targetIdx+1], tb = data[targetIdx+2], ta = data[targetIdx+3];

                // If opacity is 0 and we are erasing, nothing to do
                if(ta === 0 && mode === 'erase') return;
                // If filling with same color, nothing to do
                if(mode === 'fill' && Math.abs(tr-fillColor.r) < 5 && Math.abs(tg-fillColor.g) < 5 && Math.abs(tb-fillColor.b) < 5) return;

                // Stack-based flood fill
                const stack = [[localX, localY]];
                const seen = new Uint8Array(w * h); // track visited pixels
                
                while(stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;

                    if(seen[cy * w + cx]) continue;
                    
                    const cr = data[idx], cg = data[idx+1], cb = data[idx+2], ca = data[idx+3];
                    
                    // Check difference
                    const diff = Math.abs(cr - tr) + Math.abs(cg - tg) + Math.abs(cb - tb) + Math.abs(ca - ta);
                    
                    // Simple tolerance check
                    if (diff <= tolerance * 4) {
                        seen[cy * w + cx] = 1; // Mark visited

                        // Perform Action
                        if(mode === 'erase') {
                            data[idx+3] = 0; // Set alpha to 0
                        } else if (mode === 'fill') {
                            data[idx] = fillColor.r;
                            data[idx+1] = fillColor.g;
                            data[idx+2] = fillColor.b;
                            data[idx+3] = 255; // Ensure fully opaque
                        }

                        // Add neighbors
                        if(cx > 0) stack.push([cx-1, cy]);
                        if(cx < w-1) stack.push([cx+1, cy]);
                        if(cy > 0) stack.push([cx, cy-1]);
                        if(cy < h-1) stack.push([cx, cy+1]);
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }
        }

        class TextLayer extends Layer {
            constructor(text, id) {
                super('text', id);
                this.text = text;
                this.fontFamily = 'Arial';
                this.fontSize = 60;
                this.color = '#ffffff';
                this.textTransform = 'none'; // none, uppercase, lowercase
                this.measureDimensions();
            }

            serialize() {
                const base = super.serialize();
                return {
                    ...base,
                    text: this.text,
                    fontFamily: this.fontFamily,
                    fontSize: this.fontSize,
                    color: this.color,
                    textTransform: this.textTransform
                };
            }

            getRenderText() {
                if (this.textTransform === 'uppercase') return this.text.toUpperCase();
                if (this.textTransform === 'lowercase') return this.text.toLowerCase();
                return this.text;
            }

            measureDimensions() {
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                const metrics = ctx.measureText(this.getRenderText());
                this.width = metrics.width;
                this.height = this.fontSize; 
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.fillStyle = this.color;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                ctx.fillText(this.getRenderText(), 0, 0);
                ctx.restore();
            }
        }

        // --- Core Application ---

        class EditorApp {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.layers = [];
                this.history = [];
                this.historyMax = 20;
                this.activeLayer = null;
                this.tool = 'move'; 
                this.zoom = 1;
                this.isDragging = false;
                this.isRotating = false;
                this.isResizing = false;
                this.lastMouse = { x: 0, y: 0 };
                this.bgColor = '#1a1a1a';
                this.hasUnsavedChanges = false;
                
                this.initEvents();
                this.loop();
                // Initial state
                this.saveState();
            }

            // --- History System (Undo) ---
            saveState() {
                // Serialize all layers
                const state = {
                    bgColor: this.bgColor,
                    layers: this.layers.map(l => l.serialize())
                };

                // Add to history
                this.history.push(state);
                if (this.history.length > this.historyMax) {
                    this.history.shift(); // Remove oldest
                }
                
                this.updateUndoButton();
                this.hasUnsavedChanges = false;
            }

            undo() {
                if (this.history.length <= 1) return;

                // Remove current state
                this.history.pop();
                // Get previous state
                const prevState = this.history[this.history.length - 1];
                
                this.restoreState(prevState);
                this.updateUndoButton();
            }

            restoreState(state) {
                this.bgColor = state.bgColor;
                document.getElementById('bg-color').value = this.bgColor;

                this.layers = state.layers.map(data => {
                    let layer;
                    if (data.type === 'image') {
                        // Reconstruct image layer with pixel data
                        layer = new ImageLayer(data.originalImage, data.id);
                        layer.ctx.putImageData(data.imageData, 0, 0);
                    } else {
                        layer = new TextLayer(data.text, data.id);
                        layer.fontFamily = data.fontFamily;
                        layer.fontSize = data.fontSize;
                        layer.color = data.color;
                        layer.textTransform = data.textTransform || 'none';
                    }
                    // Restore transform props
                    layer.x = data.x;
                    layer.y = data.y;
                    layer.rotation = data.rotation;
                    layer.scale = data.scale;
                    layer.opacity = data.opacity;
                    layer.width = data.width;
                    layer.height = data.height;
                    return layer;
                });

                this.setActiveLayer(null); // Reset selection to avoid ghosting
            }

            updateUndoButton() {
                const btn = document.getElementById('undo-btn');
                btn.disabled = this.history.length <= 1;
            }

            // --- Events & Logic ---

            initEvents() {
                // Drag & Drop
                const workspace = document.getElementById('workspace');
                workspace.addEventListener('dragover', (e) => e.preventDefault());
                workspace.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const file = e.dataTransfer.files[0];
                    if(file && file.type.startsWith('image/')) {
                        this.saveState(); // Save before add
                        this.loadImage(file);
                    }
                });

                // Paste
                window.addEventListener('paste', (e) => {
                    const item = e.clipboardData.items[0];
                    if (item && item.type.indexOf("image") !== -1) {
                        this.saveState(); // Save before add
                        this.loadImage(item.getAsFile());
                    }
                });

                // Canvas Interactions
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                window.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: ()=>{} });
                }, {passive: false});

                // UI Bindings
                document.getElementById('bg-color').addEventListener('change', (e) => {
                    this.bgColor = e.target.value;
                    this.saveState();
                });
                
                // Property Bindings (Real-time update, save state on change 'change' or blur)
                const propInputs = ['prop-opacity', 'prop-text-content', 'prop-font', 'prop-color'];
                propInputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        this.handlePropertyChange(e);
                    });
                    // Save state only when user finishes dragging slider or typing
                    document.getElementById(id).addEventListener('change', () => this.saveState());
                });
                
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    }
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if(this.activeLayer) {
                            this.saveState();
                            this.deleteLayer();
                        }
                    }
                    if (e.key === 'v') this.setTool('move');
                    if (e.key === 'e') this.setTool('eraser');
                    if (e.key === 'f') this.setTool('fill');
                });
            }

            handlePropertyChange(e) {
                if(!this.activeLayer) return;
                const target = e.target;
                
                if(target.id === 'prop-opacity') this.activeLayer.opacity = target.value;
                if(target.id === 'prop-text-content' && this.activeLayer.type === 'text') {
                    this.activeLayer.text = target.value;
                    this.activeLayer.measureDimensions();
                }
                if(target.id === 'prop-font' && this.activeLayer.type === 'text') {
                    // Split value to check for transform
                    const [family, transform] = target.value.split('|');
                    this.activeLayer.fontFamily = family;
                    this.activeLayer.textTransform = transform || 'none';
                    this.activeLayer.measureDimensions();
                }
                if(target.id === 'prop-color' && this.activeLayer.type === 'text') {
                    this.activeLayer.color = target.value;
                }
            }

            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width, h = img.height;
                        if(w > 1500 || h > 1500) {
                            const ratio = Math.min(1500/w, 1500/h);
                            w *= ratio; h *= ratio;
                        }
                        const layer = new ImageLayer(img, Date.now());
                        if(layer.width > 1080) {
                            layer.scale = 1080 / layer.width * 0.8;
                        }
                        this.addLayer(layer);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            addTextLayer() {
                this.saveState();
                const layer = new TextLayer('Nuevo Texto', Date.now());
                this.addLayer(layer);
                this.setTool('move');
            }

            addLayer(layer) {
                this.layers.push(layer);
                this.setActiveLayer(layer);
                this.saveState();
            }

            deleteLayer() {
                if(!this.activeLayer) return;
                this.layers = this.layers.filter(l => l !== this.activeLayer);
                this.setActiveLayer(null);
                this.saveState();
            }

            reorderLayer(direction) {
                if(!this.activeLayer) return;
                const idx = this.layers.indexOf(this.activeLayer);
                if(direction === 'up' && idx < this.layers.length - 1) {
                    [this.layers[idx], this.layers[idx+1]] = [this.layers[idx+1], this.layers[idx]];
                    this.saveState();
                } else if (direction === 'down' && idx > 0) {
                    [this.layers[idx], this.layers[idx-1]] = [this.layers[idx-1], this.layers[idx]];
                    this.saveState();
                }
            }
            
            centerLayer() {
                if(this.activeLayer) {
                    this.saveState();
                    this.activeLayer.x = 1080/2;
                    this.activeLayer.y = 1080/2;
                    this.saveState();
                }
            }

            setActiveLayer(layer) {
                if(this.activeLayer) this.activeLayer.selected = false;
                this.activeLayer = layer;
                if(layer) layer.selected = true;
                this.updatePropertiesPanel();
            }

            setTool(name) {
                this.tool = name;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                const btn = document.getElementById(`tool-${name}`);
                if(btn) btn.classList.add('active');
                
                // Toggle settings visibility
                const toolSettings = document.getElementById('tool-settings');
                const eraserSet = document.getElementById('eraser-settings');
                const wandSet = document.getElementById('wand-settings');
                const fillSet = document.getElementById('fill-settings');
                
                toolSettings.style.display = (name === 'eraser' || name === 'magic-wand' || name === 'fill') ? 'block' : 'none';
                
                eraserSet.style.display = name === 'eraser' ? 'block' : 'none';
                wandSet.style.display = name === 'magic-wand' ? 'block' : 'none';
                fillSet.style.display = name === 'fill' ? 'block' : 'none';
            }
            
            setZoom(delta) {
                this.zoom = Math.max(0.1, Math.min(3, this.zoom + delta));
                const container = document.getElementById('canvas-container');
                container.style.transform = `scale(${this.zoom})`;
                document.getElementById('zoom-level').innerText = Math.round(this.zoom * 100) + '%';
            }

            updatePropertiesPanel() {
                const noSel = document.getElementById('no-selection-msg');
                const props = document.getElementById('layer-properties');
                
                if(!this.activeLayer) {
                    noSel.style.display = 'block';
                    props.style.display = 'none';
                    return;
                }
                
                noSel.style.display = 'none';
                props.style.display = 'block';
                
                const textControls = document.getElementById('text-controls');
                document.getElementById('prop-opacity').value = this.activeLayer.opacity;
                
                if(this.activeLayer.type === 'text') {
                    textControls.style.display = 'block';
                    document.getElementById('prop-text-content').value = this.activeLayer.text;
                    // Reconstruct the value for the dropdown (Family|Transform)
                    let val = this.activeLayer.fontFamily;
                    if (this.activeLayer.textTransform && this.activeLayer.textTransform !== 'none') {
                        val += '|' + this.activeLayer.textTransform;
                    }
                    
                    // Select the option, defaulting to just the font family if exact match fails
                    const select = document.getElementById('prop-font');
                    if ([...select.options].some(o => o.value === val)) {
                        select.value = val;
                    } else {
                        select.value = this.activeLayer.fontFamily;
                    }

                    document.getElementById('prop-color').value = this.activeLayer.color;
                } else {
                    textControls.style.display = 'none';
                }
            }

            getMousePos(evt) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.lastMouse = pos;
                
                if (this.tool === 'move') {
                    if(this.activeLayer && this.activeLayer.selected) {
                        if (this.checkRotationHandle(pos)) {
                            this.isRotating = true; return;
                        }
                        if (this.checkResizeHandle(pos)) {
                            this.isResizing = true; return;
                        }
                    }

                    let clickedLayer = null;
                    for(let i = this.layers.length - 1; i >= 0; i--) {
                        if(this.layers[i].contains(pos.x, pos.y)) {
                            clickedLayer = this.layers[i];
                            break;
                        }
                    }

                    if(clickedLayer) {
                        this.setActiveLayer(clickedLayer);
                        this.isDragging = true;
                    } else {
                        this.setActiveLayer(null);
                    }
                } else if (this.activeLayer && this.activeLayer.type === 'image') {
                    if (this.tool === 'eraser') {
                        const size = parseInt(document.getElementById('eraser-size').value);
                        this.activeLayer.erase(pos.x, pos.y, size);
                        this.isDragging = true; 
                        this.hasUnsavedChanges = true;
                    } else if (this.tool === 'magic-wand') {
                        this.saveState(); // Save before wand
                        const tol = parseInt(document.getElementById('wand-tol').value);
                        this.activeLayer.magicWand(pos.x, pos.y, tol);
                        this.saveState(); // Save after wand
                    } else if (this.tool === 'fill') {
                        this.saveState(); // Save before fill
                        const tol = parseInt(document.getElementById('fill-tol').value);
                        const color = document.getElementById('fill-color').value;
                        this.activeLayer.floodFill(pos.x, pos.y, color, tol);
                        this.saveState();
                    }
                }
            }

            handleMouseMove(e) {
                const pos = this.getMousePos(e);

                if (this.tool === 'move') {
                    if (this.isDragging && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        let nx = this.activeLayer.x + (pos.x - this.lastMouse.x);
                        let ny = this.activeLayer.y + (pos.y - this.lastMouse.y);
                        if (Math.abs(nx - 1080/2) < 10) nx = 1080/2;
                        if (Math.abs(ny - 1080/2) < 10) ny = 1080/2;
                        this.activeLayer.x = nx;
                        this.activeLayer.y = ny;
                    } else if (this.isRotating && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        const dx = pos.x - this.activeLayer.x;
                        const dy = pos.y - this.activeLayer.y;
                        this.activeLayer.rotation = Math.atan2(dy, dx) + Math.PI / 2;
                    } else if (this.isResizing && this.activeLayer) {
                        this.hasUnsavedChanges = true;
                        const dx = pos.x - this.activeLayer.x;
                        const dy = pos.y - this.activeLayer.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const baseSize = Math.sqrt(Math.pow(this.activeLayer.width/2, 2) + Math.pow(this.activeLayer.height/2, 2));
                        this.activeLayer.scale = dist / baseSize;
                    }
                } else if (this.tool === 'eraser' && this.isDragging && this.activeLayer) {
                    const size = parseInt(document.getElementById('eraser-size').value);
                    this.activeLayer.erase(pos.x, pos.y, size);
                }

                this.lastMouse = pos;
            }

            handleMouseUp() {
                this.isDragging = false;
                this.isRotating = false;
                this.isResizing = false;
                
                // If we were dragging/editing, save state now
                if (this.hasUnsavedChanges) {
                    this.saveState();
                    this.hasUnsavedChanges = false;
                }
            }

            checkRotationHandle(pos) {
                const l = this.activeLayer;
                const cx = l.x + Math.sin(l.rotation) * (l.height * l.scale / 2 + 40);
                const cy = l.y - Math.cos(l.rotation) * (l.height * l.scale / 2 + 40);
                return Math.abs(pos.x - cx) < 10 && Math.abs(pos.y - cy) < 10;
            }

            checkResizeHandle(pos) {
                const l = this.activeLayer;
                const cos = Math.cos(l.rotation);
                const sin = Math.sin(l.rotation);
                const dx = l.width/2 * l.scale;
                const dy = l.height/2 * l.scale;
                const cx = l.x + dx*cos - dy*sin;
                const cy = l.y + dx*sin + dy*cos;
                return Math.abs(pos.x - cx) < 15 && Math.abs(pos.y - cy) < 15;
            }

            drawUI(ctx) {
                if(!this.activeLayer || !this.activeLayer.selected) return;
                
                const l = this.activeLayer;
                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rotation);
                
                ctx.strokeStyle = '#00ff9d';
                ctx.lineWidth = 2;
                const w = l.width * l.scale;
                const h = l.height * l.scale;
                ctx.strokeRect(-w/2, -h/2, w, h);
                
                ctx.beginPath();
                ctx.moveTo(0, -h/2);
                ctx.lineTo(0, -h/2 - 40);
                ctx.stroke();

                ctx.fillStyle = '#00ff9d';
                ctx.beginPath();
                ctx.arc(0, -h/2 - 40, 6, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(w/2, h/2, 6, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
                
                if(this.tool === 'eraser') {
                    const size = parseInt(document.getElementById('eraser-size').value);
                    const mouse = this.lastMouse;
                    ctx.save();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(mouse.x, mouse.y, size, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }

                if(this.isDragging && this.tool === 'move') {
                    if(Math.abs(l.x - 1080/2) < 1) {
                        ctx.beginPath(); ctx.moveTo(1080/2, 0); ctx.lineTo(1080/2, 1080);
                        ctx.strokeStyle = '#00a8ff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                    }
                    if(Math.abs(l.y - 1080/2) < 1) {
                        ctx.beginPath(); ctx.moveTo(0, 1080/2); ctx.lineTo(1080, 1080/2);
                        ctx.strokeStyle = '#00a8ff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                    }
                }
            }

            loop() {
                this.ctx.fillStyle = this.bgColor;
                this.ctx.fillRect(0, 0, 1080, 1080);
                this.layers.forEach(layer => layer.draw(this.ctx));
                this.drawUI(this.ctx);
                requestAnimationFrame(this.loop.bind(this));
            }

            handleImageUpload(input) {
                if (input.files && input.files[0]) {
                    this.saveState();
                    this.loadImage(input.files[0]);
                }
            }

            exportImage() {
                const prevSelection = this.activeLayer;
                this.setActiveLayer(null);
                this.ctx.fillStyle = this.bgColor;
                this.ctx.fillRect(0, 0, 1080, 1080);
                this.layers.forEach(layer => layer.draw(this.ctx));
                
                const format = document.getElementById('export-format').value;
                const link = document.createElement('a');
                link.download = `ecopiensa-design.${format.split('/')[1]}`;
                link.href = this.canvas.toDataURL(format, 0.9);
                link.click();

                this.setActiveLayer(prevSelection);
            }

            // --- Profile & Preview Logic ---

            toggleGridPreview() {
                const modal = document.getElementById('preview-modal');
                const isOpen = modal.classList.contains('open');
                
                if(!isOpen) {
                    const prevSelection = this.activeLayer;
                    this.setActiveLayer(null);
                    this.ctx.fillStyle = this.bgColor;
                    this.ctx.fillRect(0, 0, 1080, 1080);
                    this.layers.forEach(layer => layer.draw(this.ctx));
                    
                    document.getElementById('preview-img').src = this.canvas.toDataURL();
                    this.setActiveLayer(prevSelection);
                    modal.classList.add('open');
                } else {
                    modal.classList.remove('open');
                }
            }

            handleProfilePic(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const url = `url(${e.target.result})`;
                        document.getElementById('prev-avatar').style.backgroundImage = url;
                    };
                    reader.readAsDataURL(input.files[0]);
                }
            }

            updateProfilePreview() {
                const name = document.getElementById('profile-name').value;
                const caption = document.getElementById('profile-caption').value;
                
                document.getElementById('prev-username').innerText = name;
                document.getElementById('prev-username-cap').innerText = name;
                document.getElementById('prev-caption-text').innerText = caption;
            }
        }

        window.app = new EditorApp();
        
        document.getElementById('eraser-size').addEventListener('input', (e) => {
            document.getElementById('eraser-size-val').innerText = e.target.value;
        });
        document.getElementById('wand-tol').addEventListener('input', (e) => {
            document.getElementById('wand-tol-val').innerText = e.target.value;
        });
        document.getElementById('fill-tol').addEventListener('input', (e) => {
            document.getElementById('fill-tol-val').innerText = e.target.value;
        });

    </script>
</body>
</html>
